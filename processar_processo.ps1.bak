<#!
processar_processo.ps1
Pipeline completo para tratamento de processos de peritagem GEP.
Execute com PowerShell 7:  .\processar_processo.ps1
#>

[CmdletBinding()]
param()

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'
$script:LogPath = $null

function As-Text {
    param([Parameter(ValueFromPipeline = $true)]$Value)
    if ($null -eq $Value) { return '' }
    if ($Value -is [System.Management.Automation.ErrorRecord]) {
        $msg = if ($Value.Exception) { $Value.Exception.Message } else { $Value.ToString() }
        return ($msg | Out-String).Trim()
    }
    if ($Value -is [System.Collections.IEnumerable] -and -not ($Value -is [string])) {
        return (($Value | Out-String)).Trim()
    }
    return (($Value | Out-String)).Trim()
}

function Write-Log {
    param(
        [Parameter(Mandatory = $true)] [object] $Message,
        [ValidateSet('INFO','WARN','ERRO','OK')] [string] $Level = 'INFO'
    )
    $text = As-Text $Message
    $tag = if ($Level -eq 'OK') { '[OK]   ' } else { "[$Level] " }
    Write-Host "$tag$text"
    if ($script:LogPath) {
        $timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
        Add-Content -LiteralPath $script:LogPath -Value "$timestamp $tag$text"
    }
}

function Log-Info { param($Message) Write-Log $Message 'INFO' }
function Log-Warn { param($Message) Write-Log $Message 'WARN' }
function Log-Error { param($Message) Write-Log $Message 'ERRO' }
function Log-Ok   { param($Message) Write-Log $Message 'OK' }

function Coalesce-Text {
    param(
        [Parameter(Mandatory = $true)][AllowNull()][object]$Value,
        [string]$Default = '(não encontrado)'
    )
    if ($null -eq $Value) { return $Default }
    $text = [string]$Value
    if ([string]::IsNullOrWhiteSpace($text)) { return $Default }
    return $text
}

function Get-FieldOrDefault {
    param(
        [hashtable]$Fields,
        [string]$Key,
        [string]$Default = '(não encontrado)'
    )
    if ($null -eq $Fields) { return $Default }
    if (-not $Fields.ContainsKey($Key)) { return $Default }
    return Coalesce-Text -Value $Fields[$Key] -Default $Default
}

function Import-Ini {
    param([Parameter(Mandatory = $true)][string]$Path)
    if (-not (Test-Path -LiteralPath $Path)) {
        throw "Ficheiro de configuração não encontrado: $Path"
    }
    $result = @{}
    $section = ''
    foreach ($line in Get-Content -LiteralPath $Path) {
        $trim = $line.Trim()
        if ($trim -eq '' -or $trim.StartsWith(';') -or $trim.StartsWith('#')) { continue }
        if ($trim.StartsWith('[') -and $trim.EndsWith(']')) {
            $section = $trim.Trim('[',']')
            if (-not $result.ContainsKey($section)) { $result[$section] = @{} }
            continue
        }
        $parts = $trim.Split('=',2)
        if ($parts.Count -eq 2) {
            $key = $parts[0].Trim()
            $value = $parts[1].Trim()
            if ($section) {
                $result[$section][$key] = $value
            } else {
                $result[$key] = $value
            }
        }
    }
    return $result
}

function Invoke-External {
    param(
        [Parameter(Mandatory = $true)][string]$ExePath,
        [string[]]$Args = @(),
        [int]$TimeoutSeconds = 300
    )
    if (-not (Test-Path -LiteralPath $ExePath)) {
        throw "Executável não encontrado: $ExePath"
    }
    $psi = [System.Diagnostics.ProcessStartInfo]::new()
    $psi.FileName = $ExePath
    $psi.RedirectStandardOutput = $true
    $psi.RedirectStandardError = $true
    $psi.UseShellExecute = $false
    $psi.CreateNoWindow = $true
    foreach ($arg in $Args) { [void]$psi.ArgumentList.Add($arg) }
    $process = [System.Diagnostics.Process]::new()
    $process.StartInfo = $psi
    $null = $process.Start()
    if (-not $process.WaitForExit($TimeoutSeconds * 1000)) {
        $process.Kill()
        $process.Dispose()
        throw "Timeout ao executar: $ExePath"
    }
    $stdout = $process.StandardOutput.ReadToEnd()
    $stderr = $process.StandardError.ReadToEnd()
    $exitCode = $process.ExitCode
    $process.Dispose()
    return [pscustomobject]@{ ExitCode = $exitCode; StdOut = $stdout; StdErr = $stderr }
}

function Ensure-ProcessFolders {
    param([Parameter(Mandatory = $true)][string]$Base)
    $dirs = @(
        $Base,
        (Join-Path -Path $Base -ChildPath 'origem'),
        (Join-Path -Path $Base -ChildPath 'trabalho'),
        (Join-Path -Path $Base -ChildPath 'output')
    )
    foreach ($dir in $dirs) {
        if (-not (Test-Path -LiteralPath $dir)) {
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
            Log-Ok ("Criada pasta: {0}" -f $dir)
        } else {
            Log-Info ("Pasta já existia: {0}" -f $dir)
        }
    }
    return [ordered]@{
        Base     = $dirs[0]
        Origem   = $dirs[1]
        Trabalho = $dirs[2]
        Output   = $dirs[3]
    }
}

function Select-InputFile {
    Add-Type -AssemblyName System.Windows.Forms
    $dialog = New-Object System.Windows.Forms.OpenFileDialog
    $dialog.Filter = "Ficheiros suportados (*.pdf;*.jpg;*.jpeg;*.png;*.tif;*.tiff)|*.pdf;*.jpg;*.jpeg;*.png;*.tif;*.tiff"
    $dialog.Multiselect = $false
    $dialog.Title = "Seleccione o ficheiro do processo"
    if ($dialog.ShowDialog() -ne [System.Windows.Forms.DialogResult]::OK) {
        throw "Operação cancelada pelo utilizador."
    }
    return $dialog.FileName
}

function Get-ProcessIdFromFileName {
    param([string]$FilePath)
    $name = [System.IO.Path]::GetFileNameWithoutExtension($FilePath)
    $match = [regex]::Match($name, "apn[\s_-]*(?<id>[0-9A-Za-z]+)", 'IgnoreCase')
    if ($match.Success) {
        return $match.Groups['id'].Value.ToUpper()
    }
    return $name.ToUpper()
}

function Copy-SourceFile {
    param(
        [string]$InputPath,
        [string]$OrigemFolder
    )
    $destPath = Join-Path $OrigemFolder ([System.IO.Path]::GetFileName($InputPath))
    Copy-Item -LiteralPath $InputPath -Destination $destPath -Force
    Log-Info ("Ficheiro copiado para {0}" -f $destPath)
    return $destPath
}

function Preflight-Tools {
    param([hashtable]$Tools)
    Log-Info ("PowerShell: {0}" -f $PSVersionTable.PSVersion.ToString())

    $pdftotextOk = $false
    $tesseractOk = $false

    if ([string]::IsNullOrWhiteSpace($Tools.pdftotext)) {
        Log-Error 'Caminho de pdftotext não definido no config.ini.'
    } elseif (-not (Test-Path -LiteralPath $Tools.pdftotext)) {
        Log-Error ("pdftotext não encontrado: {0}" -f $Tools.pdftotext)
    } else {
        Log-Info ('pdftotext: "{0}"' -f $Tools.pdftotext)
        try {
            $result = Invoke-External -ExePath $Tools.pdftotext -Args @('-v') -TimeoutSeconds 30
            $combined = As-Text ($result.StdOut + $result.StdErr)
            $versionLine = ($combined -split "`r?`n" | Where-Object { $_ -match '(?i)pdftotext.*version' } | Select-Object -First 1)
            if (-not $versionLine) {
                $versionLine = ($combined -split "`r?`n" | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | Select-Object -First 1)
            }
            if (($result.ExitCode -eq 0 -and $versionLine) -or ($combined -match '(?i)pdftotext.*version')) {
                Log-Ok ("pdftotext disponível: {0}" -f (Coalesce-Text $versionLine 'versão desconhecida'))
                $pdftotextOk = $true
            } else {
                Log-Error ("pdftotext indisponível: {0}" -f (Coalesce-Text $combined 'sem resposta'))
            }
        } catch {
            Log-Error ("pdftotext falhou: {0}" -f (As-Text $_))
        }
    }

    if ([string]::IsNullOrWhiteSpace($Tools.tesseract)) {
        Log-Warn 'Caminho de tesseract não definido no config.ini.'
    } elseif (-not (Test-Path -LiteralPath $Tools.tesseract)) {
        Log-Warn ("tesseract não encontrado: {0}" -f $Tools.tesseract)
    } else {
        Log-Info ('tesseract: "{0}"' -f $Tools.tesseract)
        try {
            $tess = Invoke-External -ExePath $Tools.tesseract -Args @('--version') -TimeoutSeconds 30
            $combinedT = As-Text ($tess.StdOut + $tess.StdErr)
            $line = ($combinedT -split "`r?`n" | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | Select-Object -First 1)
            if ($tess.ExitCode -eq 0 -and $line) {
                Log-Ok ("tesseract disponível: {0}" -f $line)
                $tesseractOk = $true
            } else {
                Log-Warn ("tesseract indisponível: {0}" -f (Coalesce-Text $combinedT 'sem resposta'))
            }
        } catch {
            Log-Warn ("tesseract falhou: {0}" -f (As-Text $_))
        }
    }

    return [pscustomobject]@{
        PdftotextOk = $pdftotextOk
        TesseractOk = $tesseractOk
    }
}

function Invoke-TesseractImage {
    param(
        [string]$ImagePath,
        [string]$TesseractExe,
        [string]$WorkDir
    )
    if (-not (Test-Path -LiteralPath $TesseractExe)) {
        return [pscustomobject]@{ Success = $false; Text = ''; Message = 'tesseract.exe indisponível.' }
    }
    $safeName = [System.IO.Path]::GetFileNameWithoutExtension($ImagePath)
    $outputBase = Join-Path $WorkDir ("ocr_" + $safeName + '_' + (Get-Random))
    $args = @($ImagePath, $outputBase, '-l','por','--psm','3')
    try {
        $exec = Invoke-External -ExePath $TesseractExe -Args $args -TimeoutSeconds 180
        $txtFile = $outputBase + '.txt'
        if (Test-Path -LiteralPath $txtFile) {
            $text = Get-Content -LiteralPath $txtFile -Raw
            return [pscustomobject]@{ Success = ([string]::IsNullOrWhiteSpace($text) -eq $false); Text = $text; Message = As-Text ($exec.StdErr) }
        }
    } catch {
        return [pscustomobject]@{ Success = $false; Text = ''; Message = (As-Text $_) }
    }
    return [pscustomobject]@{ Success = $false; Text = ''; Message = 'tesseract não gerou texto.' }
}

function Extract-Text {
    param(
        [Parameter(Mandatory = $true)][string]$InputPath,
        [Parameter(Mandatory = $true)][string]$TxtOut,
        [Parameter(Mandatory = $true)][string]$WorkDir,
        [Parameter(Mandatory = $true)][string]$PdftotextExe,
        [string]$TesseractExe,
        [string]$PdftoppmExe
    )
    if (-not (Test-Path -LiteralPath $WorkDir)) {
        New-Item -ItemType Directory -Path $WorkDir -Force | Out-Null
    }
    if (Test-Path -LiteralPath $TxtOut) {
        Remove-Item -LiteralPath $TxtOut -Force
    }
    $extension = ([System.IO.Path]::GetExtension($InputPath)).ToLowerInvariant()
    switch ($extension) {
        '.pdf' { return Extract-TextFromPdf -InputPath $InputPath -TxtOut $TxtOut -WorkDir $WorkDir -PdftotextExe $PdftotextExe -TesseractExe $TesseractExe -PdftoppmExe $PdftoppmExe }
        '.jpg' { return Extract-TextFromImage -InputPath $InputPath -TxtOut $TxtOut -WorkDir $WorkDir -TesseractExe $TesseractExe }
        '.jpeg' { return Extract-TextFromImage -InputPath $InputPath -TxtOut $TxtOut -WorkDir $WorkDir -TesseractExe $TesseractExe }
        '.png' { return Extract-TextFromImage -InputPath $InputPath -TxtOut $TxtOut -WorkDir $WorkDir -TesseractExe $TesseractExe }
        '.tif' { return Extract-TextFromImage -InputPath $InputPath -TxtOut $TxtOut -WorkDir $WorkDir -TesseractExe $TesseractExe }
        '.tiff' { return Extract-TextFromImage -InputPath $InputPath -TxtOut $TxtOut -WorkDir $WorkDir -TesseractExe $TesseractExe }
        default {
            Log-Error ("Extensão não suportada: {0}" -f $extension)
            return $false
        }
    }
}

function Extract-TextFromPdf {
    param(
        [string]$InputPath,
        [string]$TxtOut,
        [string]$WorkDir,
        [string]$PdftotextExe,
        [string]$TesseractExe,
        [string]$PdftoppmExe
    )
    if (Test-Path -LiteralPath $PdftotextExe) {
        $tmpTxt = Join-Path $WorkDir 'doc_pdftotext.txt'
        if (Test-Path -LiteralPath $tmpTxt) { Remove-Item -LiteralPath $tmpTxt -Force }
        try {
            $args = @('-layout','-nopgbrk','-enc','UTF-8', $InputPath, $tmpTxt)
            $null = Invoke-External -ExePath $PdftotextExe -Args $args -TimeoutSeconds 180
            if (Test-Path -LiteralPath $tmpTxt -and (Get-Item -LiteralPath $tmpTxt).Length -gt 0) {
                Move-Item -LiteralPath $tmpTxt -Destination $TxtOut -Force
                Log-Ok 'Texto gerado com pdftotext.'
                return $true
            }
        } catch {
            Log-Warn ("pdftotext falhou: {0}" -f (As-Text $_))
        }
    } else {
        Log-Warn 'pdftotext.exe não disponível para extração direta.'
    }

    if (-not (Test-Path -LiteralPath $TesseractExe)) {
        Log-Error 'OCR não disponível porque tesseract.exe não está configurado.'
        return $false
    }
    if (-not (Test-Path -LiteralPath $PdftoppmExe)) {
        Log-Error 'OCR não disponível porque pdftoppm.exe não foi encontrado.'
        return $false
    }

    $ocrDir = Join-Path $WorkDir 'ocr_pages'
    New-Item -ItemType Directory -Path $ocrDir -Force | Out-Null
    $baseOutput = Join-Path $ocrDir 'page'
    try {
        $argsPpm = @('-png', $InputPath, $baseOutput)
        $null = Invoke-External -ExePath $PdftoppmExe -Args $argsPpm -TimeoutSeconds 300
    } catch {
        Log-Error ("pdftoppm falhou: {0}" -f (As-Text $_))
        return $false
    }

    $builder = [System.Text.StringBuilder]::new()
    $pngFiles = Get-ChildItem -LiteralPath $ocrDir -Filter 'page*.png' | Sort-Object Name
    foreach ($png in $pngFiles) {
        $ocrResult = Invoke-TesseractImage -ImagePath $png.FullName -TesseractExe $TesseractExe -WorkDir $ocrDir
        if ($ocrResult.Success) {
            [void]$builder.AppendLine($ocrResult.Text)
        } else {
            Log-Warn ("OCR falhou para {0}: {1}" -f $png.Name, $ocrResult.Message)
        }
    }

    $content = $builder.ToString()
    if (-not [string]::IsNullOrWhiteSpace($content)) {
        Set-Content -LiteralPath $TxtOut -Value $content -Encoding UTF8
        Log-Ok 'Texto gerado por OCR (PDF imagem).'
        return $true
    }

    Log-Error 'OCR não produziu texto.'
    return $false
}

function Extract-TextFromImage {
    param(
        [string]$InputPath,
        [string]$TxtOut,
        [string]$WorkDir,
        [string]$TesseractExe
    )
    if (-not (Test-Path -LiteralPath $TesseractExe)) {
        Log-Error 'OCR não disponível porque tesseract.exe não está configurado.'
        return $false
    }
    $ocrResult = Invoke-TesseractImage -ImagePath $InputPath -TesseractExe $TesseractExe -WorkDir $WorkDir
    if ($ocrResult.Success -and -not [string]::IsNullOrWhiteSpace($ocrResult.Text)) {
        Set-Content -LiteralPath $TxtOut -Value $ocrResult.Text -Encoding UTF8
        Log-Ok 'Texto gerado por OCR (imagem).'
        return $true
    }
    Log-Error 'OCR não produziu texto.'
    return $false
}

function Read-TextContent {
    param([string]$TextPath)
    return [System.IO.File]::ReadAllText($TextPath, [System.Text.Encoding]::UTF8)
}

function Select-RegexFirst {
    param(
        [string]$Text,
        [string]$Pattern,
        [string]$Options = 'IgnoreCase'
    )
    $regex = [System.Text.RegularExpressions.Regex]::new($Pattern, $Options)
    $match = $regex.Match($Text)
    if ($match.Success) {
        if ($match.Groups.Count -gt 1) {
            return $match.Groups[1].Value.Trim()
        }
        return $match.Value.Trim()
    }
    return ''
}

function Validate-OrEmpty {
    param(
        [string]$Value,
        [string]$Pattern
    )
    if ([string]::IsNullOrWhiteSpace($Value)) { return '' }
    if ($Value -match $Pattern) { return $Value.Trim() }
    return ''
}

function Extract-Fields {
    param([string]$Text)
    $fields = [ordered]@{}
    $fields['nome'] = Select-RegexFirst $Text "Nome[:\s]*([^\r\n]+)"
    $fields['morada'] = Select-RegexFirst $Text "Morada[:\s]*([^\r\n]+)"
    $fields['localidade'] = Select-RegexFirst $Text "Localidade[:\s]*([^\r\n]+)"
    $fields['codigo_postal'] = Validate-OrEmpty (Select-RegexFirst $Text "C[oó]digo\s+Postal[:\s]*([0-9]{4}-[0-9]{3})") "^[0-9]{4}-[0-9]{3}$"
    $fields['telefone'] = Validate-OrEmpty (Select-RegexFirst $Text "Telefone[:\s]*([0-9 \+/()-]{6,})") "[0-9]{6,}"
    $fields['email'] = Validate-OrEmpty (Select-RegexFirst $Text "Email[:\s]*([A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,})" 'IgnoreCase') "^[^@\s]+@[^@\s]+\.[^@\s]+$"
    $fields['nif'] = Validate-OrEmpty (Select-RegexFirst $Text "N[º°\.\s]*de\s+Contribuinte\s*/?\s*NIPC[:\s]*([0-9]{9})") "^[0-9]{9}$"
    $fields['num_apolice'] = Select-RegexFirst $Text "N[º°\.\s]*de\s+Ap[oó]lice[:\s]*([^\r\n]+)"
    $fields['datas'] = [regex]::Matches($Text, "\b[0-3]?\d/[0-1]?\d/\d{4}\b") | ForEach-Object { $_.Value } | Select-Object -Unique
    return $fields
}

function Write-DataJson {
    param(
        [string]$JsonPath,
        [hashtable]$Fields,
        [string]$ProcessId,
        [string]$SourceFile,
        [string]$CopiedFile
    )
    $payload = [ordered]@{
        process_id = $ProcessId
        timestamp = (Get-Date).ToString('s')
        source_file = $SourceFile
        copied_file = $CopiedFile
        fields = $Fields
    }
    $json = $payload | ConvertTo-Json -Depth 6
    Set-Content -LiteralPath $JsonPath -Value $json -Encoding UTF8
    Log-Ok ("data.json criado em {0}" -f $JsonPath)
}

function Read-WordSections {
    param([string]$DocxPath)
    $sections = [ordered]@{
        Descricao = ''
        Causas = ''
        Conclusoes = ''
    }
    if (-not (Test-Path -LiteralPath $DocxPath)) {
        Log-Warn 'DOCX de descrição não encontrado (opcional).'
        return $sections
    }
    $word = $null
    $doc = $null
    try {
        $word = New-Object -ComObject Word.Application
        $word.Visible = $false
        $doc = $word.Documents.Open($DocxPath, $false, $true)
        $text = $doc.Content.Text
        $sections['Descricao']  = Get-SectionText $text "Descri[çc][aã]o" "Causas"
        $sections['Causas']     = Get-SectionText $text "Causas" "Conclus[õo]es"
        $sections['Conclusoes'] = Get-SectionText $text "Conclus[õo]es" $null
    } catch {
        Log-Warn ("Erro a ler DOCX: {0}" -f (As-Text $_))
    } finally {
        if ($doc) { $doc.Close([ref]0) }
        if ($word) { $word.Quit() }
        if ($doc) { [void][System.Runtime.InteropServices.Marshal]::ReleaseComObject($doc) }
        if ($word) { [void][System.Runtime.InteropServices.Marshal]::ReleaseComObject($word) }
    }
    return $sections
}

function Get-SectionText {
    param(
        [string]$FullText,
        [string]$HeaderPattern,
        [string]$NextHeaderPattern
    )
    $regexPattern = if ($NextHeaderPattern) {
        "(?is)$HeaderPattern\s*[:\-]*\s*(.*?)\s*(?=$NextHeaderPattern\s*[:\-]|\Z)"
    } else {
        "(?is)$HeaderPattern\s*[:\-]*\s*(.*)"
    }
    $match = [regex]::Match($FullText, $regexPattern)
    if ($match.Success) {
        return $match.Groups[1].Value.Trim()
    }
    return ''
}

function Write-FillFormJson {
    param(
        [string]$Path,
        [hashtable]$Fields,
        [hashtable]$Sections,
        [string]$ProcessId
    )
    $postal = Get-FieldOrDefault -Fields $Fields -Key 'codigo_postal' -Default ''
    if ($postal -and -not ($postal -match '^[0-9]{4}-[0-9]{3}$')) {
        Log-Warn ("Código postal inválido descartado: {0}" -f $postal)
        $postal = ''
    }
    $email = Get-FieldOrDefault -Fields $Fields -Key 'email' -Default ''
    if ($email -and -not ($email -match '^[^@\s]+@[^@\s]+\.[^@\s]+$')) {
        Log-Warn ("Email inválido descartado: {0}" -f $email)
        $email = ''
    }
    $nif = Get-FieldOrDefault -Fields $Fields -Key 'nif' -Default ''
    if ($nif -and -not ($nif -match '^[0-9]{9}$')) {
        Log-Warn ("NIF inválido descartado: {0}" -f $nif)
        $nif = ''
    }
    $datas = $Fields['datas']
    $dataOcorrencia = if ($datas -and $datas.Count -gt 0) { $datas[0] } else { '' }
    $dataEmissao = if ($datas -and $datas.Count -gt 1) { $datas[1] } else { '' }

    $form = [ordered]@{
        segurado_nome        = Get-FieldOrDefault -Fields $Fields -Key 'nome'
        segurado_morada      = Get-FieldOrDefault -Fields $Fields -Key 'morada' -Default ''
        segurado_localidade  = Get-FieldOrDefault -Fields $Fields -Key 'localidade' -Default ''
        segurado_cp          = $postal
        segurado_telefone    = Get-FieldOrDefault -Fields $Fields -Key 'telefone' -Default ''
        segurado_email       = $email
        nif_nipc             = $nif
        apolice_numero       = Get-FieldOrDefault -Fields $Fields -Key 'num_apolice' -Default ''
        apolice_companhia    = ''
        data_ocorrencia      = $dataOcorrencia
        data_emissao         = $dataEmissao
        descricao            = Coalesce-Text $Sections['Descricao'] ''
        causas               = Coalesce-Text $Sections['Causas'] ''
        conclusoes           = Coalesce-Text $Sections['Conclusoes'] ''
        processo_id          = $ProcessId
    }
    $json = $form | ConvertTo-Json -Depth 4
    Set-Content -LiteralPath $Path -Value $json -Encoding UTF8
    Log-Ok ("fillform.json criado em {0}" -f $Path)
}

function Generate-ReportPdf {
    param(
        [string]$OutputPdf,
        [hashtable]$Fields,
        [hashtable]$Sections,
        [string]$ProcessId
    )
    $word = $null
    $doc = $null
    try {
        $word = New-Object -ComObject Word.Application
        $word.Visible = $false
        $doc = $word.Documents.Add()
        $selection = $word.Selection

        $selection.Style = 'Title'
        $selection.TypeText('Relatório de Processo GEP ' + $ProcessId)
        $selection.TypeParagraph()
        $selection.TypeParagraph()

        $selection.Style = 'Heading 1'
        $selection.TypeText('Dados do Segurado')
        $selection.TypeParagraph()

        $selection.Style = 'Normal'
        $selection.TypeText('Nome: ' + (Get-FieldOrDefault -Fields $Fields -Key 'nome' -Default '(não encontrado)'))
        $selection.TypeParagraph()
        $selection.TypeText('Morada: ' + (Get-FieldOrDefault -Fields $Fields -Key 'morada' -Default ''))
        $selection.TypeParagraph()
        $selection.TypeText('Localidade: ' + (Get-FieldOrDefault -Fields $Fields -Key 'localidade' -Default ''))
        $selection.TypeParagraph()
        $selection.TypeText('Código Postal: ' + (Get-FieldOrDefault -Fields $Fields -Key 'codigo_postal' -Default ''))
        $selection.TypeParagraph()
        $selection.TypeText('Telefone: ' + (Get-FieldOrDefault -Fields $Fields -Key 'telefone' -Default ''))
        $selection.TypeParagraph()
        $selection.TypeText('Email: ' + (Get-FieldOrDefault -Fields $Fields -Key 'email' -Default ''))
        $selection.TypeParagraph()
        $selection.TypeText('NIF/NIPC: ' + (Get-FieldOrDefault -Fields $Fields -Key 'nif' -Default ''))
        $selection.TypeParagraph()
        $selection.TypeText('Nº Apólice: ' + (Get-FieldOrDefault -Fields $Fields -Key 'num_apolice' -Default ''))
        $selection.TypeParagraph()
        if ($Fields['datas']) {
            $selection.TypeText('Datas relevantes: ' + (($Fields['datas']) -join ', '))
            $selection.TypeParagraph()
        }
        $selection.TypeParagraph()

        foreach ($sectionName in @('Descricao','Causas','Conclusoes')) {
            $selection.Style = 'Heading 1'
            $label = switch ($sectionName) {
                'Descricao' { 'Descrição' }
                'Causas'    { 'Causas' }
                'Conclusoes'{ 'Conclusões' }
            }
            $selection.TypeText($label)
            $selection.TypeParagraph()
            $selection.Style = 'Normal'
            $selection.TypeText((Coalesce-Text $Sections[$sectionName] ''))
            $selection.TypeParagraph()
            $selection.TypeParagraph()
        }

        $doc.ExportAsFixedFormat($OutputPdf, 17)
        Log-Ok ("relatorio_fillform.pdf criado em {0}" -f $OutputPdf)
    } catch {
        throw "Erro ao gerar relatório PDF: $(As-Text $_)"
    } finally {
        if ($doc) { $doc.Close([ref]0) }
        if ($word) { $word.Quit() }
        if ($doc) { [void][System.Runtime.InteropServices.Marshal]::ReleaseComObject($doc) }
        if ($word) { [void][System.Runtime.InteropServices.Marshal]::ReleaseComObject($word) }
    }
}

function Create-OutlookDraft {
    param(
        [hashtable]$Fields,
        [string]$ProcessId,
        [string]$TemplatePath
    )
    $email = Get-FieldOrDefault -Fields $Fields -Key 'email' -Default ''
    if (-not $email) {
        Log-Warn 'Email do segurado ausente. Rascunho não criado.'
        return
    }
    if (-not (Test-Path -LiteralPath $TemplatePath)) {
        Log-Warn ("Template de email não encontrado em {0}." -f $TemplatePath)
        return
    }
    $html = Get-Content -LiteralPath $TemplatePath -Raw
    $placeholders = @{
        '{{NOME}}' = Get-FieldOrDefault -Fields $Fields -Key 'nome' -Default $ProcessId
        '{{NUM_APOLICE}}' = Get-FieldOrDefault -Fields $Fields -Key 'num_apolice' -Default '(sem apólice)'
        '{{DATA_PROCESSO}}' = (Get-Date).ToString('dd/MM/yyyy')
        '{{NIF}}' = Get-FieldOrDefault -Fields $Fields -Key 'nif' -Default ''
        '{{MORADA}}' = Get-FieldOrDefault -Fields $Fields -Key 'morada' -Default ''
        '{{CODIGO_POSTAL}}' = Get-FieldOrDefault -Fields $Fields -Key 'codigo_postal' -Default ''
        '{{LOCALIDADE}}' = Get-FieldOrDefault -Fields $Fields -Key 'localidade' -Default ''
    }
    foreach ($key in $placeholders.Keys) {
        $html = $html.Replace($key, $placeholders[$key])
    }
    try {
        $outlook = New-Object -ComObject Outlook.Application
        $mail = $outlook.CreateItem(0)
        $mail.To = $email
        $mail.Subject = 'Processo GEP – ' + $placeholders['{{NOME}}'] + ' / ' + $placeholders['{{NUM_APOLICE}}']
        $mail.HTMLBody = $html
        $mail.Display()
        Log-Ok 'Rascunho de email criado no Outlook.'
    } catch {
        Log-Error ("Falha ao criar rascunho no Outlook: {0}" -f (As-Text $_))
    }
}

function Initialize-Hooks {
    param([string]$WorkFolder)
    $hook = Join-Path $WorkFolder 'fillform_placeholder.txt'
    if (-not (Test-Path -LiteralPath $hook)) {
        Set-Content -LiteralPath $hook -Value 'TODO: gerar fillform.json' -Encoding UTF8
    }
}

$ScriptRoot = Split-Path -Parent $PSCommandPath
$ConfigPath = Join-Path $ScriptRoot '_config\config.ini'
$Ini = Import-Ini -Path $ConfigPath

$ToolPaths = @{
    pdftotext = Coalesce-Text -Value ($Ini.tools.pdftotext) -Default ''
    tesseract = Coalesce-Text -Value ($Ini.tools.tesseract) -Default ''
}
$ToolPaths['pdftoppm'] = if ($ToolPaths.pdftotext) { Join-Path (Split-Path $ToolPaths.pdftotext) 'pdftoppm.exe' } else { '' }

$Features = @{
    pdf   = ($Ini.features.generate_pdf -match '^(?i)(1|true|on|yes)$')
    email = ($Ini.features.generate_email -match '^(?i)(1|true|on|yes)$')
}

$BaseOutputRoot = 'H:\PROCESSOS_GEP'

try {
    $preflight = Preflight-Tools -Tools $ToolPaths
    if (-not ($preflight.PdftotextOk -or $preflight.TesseractOk)) {
        throw 'Nenhuma ferramenta disponível (pdftotext e tesseract falharam).'
    }

    $inputPath = Select-InputFile
    Log-Info ("Ficheiro seleccionado: {0}" -f $inputPath)

    $processId = Get-ProcessIdFromFileName -FilePath $inputPath
    Log-Info ("Processo identificado: {0}" -f $processId)

    $processBase = Join-Path $BaseOutputRoot $processId
    $folders = Ensure-ProcessFolders -Base $processBase
    $logFile = Join-Path $folders.Trabalho 'log.txt'
    $script:LogPath = $logFile
    Set-Content -LiteralPath $logFile -Value '' -Encoding UTF8
    Log-Info 'Log inicializado.'

    $copiedPath = Copy-SourceFile -InputPath $inputPath -OrigemFolder $folders.Origem

    $txtPath = Join-Path $folders.Trabalho 'doc.txt'
    $extractOk = Extract-Text -InputPath $copiedPath -TxtOut $txtPath -WorkDir $folders.Trabalho -PdftotextExe $ToolPaths.pdftotext -TesseractExe $ToolPaths.tesseract -PdftoppmExe $ToolPaths.pdftoppm
    if (-not $extractOk) {
        throw 'Não foi possível extrair texto do ficheiro (PDF/imagem).'
    }

    $textContent = Read-TextContent -TextPath $txtPath
    $fields = Extract-Fields -Text $textContent

    $dataJsonPath = Join-Path $folders.Trabalho 'data.json'
    Write-DataJson -JsonPath $dataJsonPath -Fields $fields -ProcessId $processId -SourceFile $inputPath -CopiedFile $copiedPath

    $docxPath = Join-Path $folders.Origem 'peritagem_descricao_causas_conclusoes.docx'
    $sections = Read-WordSections -DocxPath $docxPath

    $fillformPath = Join-Path $folders.Trabalho 'fillform.json'
    Write-FillFormJson -Path $fillformPath -Fields $fields -Sections $sections -ProcessId $processId

    Initialize-Hooks -WorkFolder $folders.Trabalho

    if ($Features.pdf) {
        $pdfReport = Join-Path $folders.Trabalho 'relatorio_fillform.pdf'
        Generate-ReportPdf -OutputPdf $pdfReport -Fields $fields -Sections $sections -ProcessId $processId
    } else {
        Log-Info 'PDF desactivado por configuração.'
    }

    if ($Features.email) {
        $templatePath = Coalesce-Text -Value ($Ini.tools.email_template) -Default ''
        if ($templatePath) {
            Create-OutlookDraft -Fields $fields -ProcessId $processId -TemplatePath $templatePath
        } else {
            Log-Warn 'Template de email não definido no config.ini.'
        }
    } else {
        Log-Info 'Email desactivado por configuração.'
    }

    Log-Ok ("Processo {0} concluído com sucesso." -f $processId)

} catch {
    $message = As-Text $_
    Log-Error $message
    Show-ErrorMessage $message | Out-Null
    exit 1
}


